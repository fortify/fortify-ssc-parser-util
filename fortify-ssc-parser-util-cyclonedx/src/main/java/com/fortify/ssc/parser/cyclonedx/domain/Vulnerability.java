/*******************************************************************************
 * (c) Copyright 2020 Micro Focus or one of its affiliates
 *
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the 
 * "Software"), to deal in the Software without restriction, including without 
 * limitation the rights to use, copy, modify, merge, publish, distribute, 
 * sublicense, and/or sell copies of the Software, and to permit persons to 
 * whom the Software is furnished to do so, subject to the following 
 * conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY 
 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 ******************************************************************************/
package com.fortify.ssc.parser.cyclonedx.domain;

import java.io.Serializable;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import org.apache.commons.lang3.StringUtils;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fortify.plugin.api.BasicVulnerabilityBuilder.Priority;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
public final class Vulnerability implements Serializable {
	private static final long serialVersionUID = 1L;
	// @JsonProperty("bom-ref") private String bom_ref;
	@JsonProperty private String id;
	@JsonProperty private Source source;
	// @JsonProperty private VulnerabilityReference[] references;
	@JsonProperty private VulnerabilityRating[] ratings;
	@JsonProperty private int[] cwes;
	@JsonProperty private String description;
	@JsonProperty private String detail;
	@JsonProperty private String recommendation;
	// @JsonProperty private VulnerabilityAdvisory[] advisories;
	// @JsonProperty private String created;
	// @JsonProperty private String published;
	// @JsonProperty private String updated;
	// @JsonProperty private VulnerabilityCredit[] credits;
	// @JsonProperty private VulnerabilityTool[] tools;
	// @JsonProperty private VulnerabilityAnalysis analysis;
	@JsonProperty private ComponentReference[] affects;
	// @JsonProperty private Property properties;
	
	public final VulnerabilityRatingSeverity getMaxSeverity() {
		if ( ratings==null ) { return VulnerabilityRatingSeverity.unknown; }
		return VulnerabilityRatingSeverity.values()[Stream.of(ratings)
			.map(VulnerabilityRating::getSeverity)
			.mapToInt(VulnerabilityRatingSeverity::ordinal)
			.min().orElseGet(VulnerabilityRatingSeverity.unknown::ordinal)];
	}
	
	public final Priority getFortifyPriority() {
		return getMaxSeverity().getFortifyPriority();
	}
	
	@Getter @NoArgsConstructor @AllArgsConstructor @Builder
	public static final class VulnerabilityRating {
		// @JsonProperty private Source source;
		@JsonProperty private float score;
		@JsonProperty private VulnerabilityRatingSeverity severity;
		@JsonProperty private VulnerabilityRatingMethod method;
		@JsonProperty private String vector;
		// @JsonProperty private String justification;
	}
	
	/**
	 * Enumeration of rating severities as allowed by CycloneDX standard. 
	 * Note that {@link Vulnerability#getMaxSeverity()} expects the enum 
	 * values to be ordered from most critical to least critical.
	 * TODO Should info/none/unknown be mapped to Low, null or other value?
	 */
	public static enum VulnerabilityRatingSeverity {
		critical(Priority.Critical), 
		high(Priority.High), 
		medium(Priority.Medium), 
		low(Priority.Low), 
		info(Priority.Low), 
		none(Priority.Low), 
		unknown(Priority.Low);
		
		private final Priority fortifyPriority;
		private VulnerabilityRatingSeverity(Priority fortifyPriority) {
			this.fortifyPriority = fortifyPriority;
		}
		
		public final Priority getFortifyPriority() {
			return fortifyPriority;
		}
	}
	
	/**
	 * Enumeration of rating method as allowed by CycloneDX standard. 
	 * The not_available value will be used if no rating is available.
	 */
	public static enum VulnerabilityRatingMethod {
		CVSSv4,
		CVSSv31,
		CVSSv3,
		CVSSv2,
		OWASP,
		SSVC,
		other,
		not_available;
	    
	    public String toString() {
	        return this==not_available ? "N/A" : name();
	    }
	}
	
	@Getter
	public static final class ComponentReference {
		@JsonProperty private String ref;
		@JsonProperty private ComponentReferenceVersion[] versions; 
	}
	
	@Getter
	public static final class ComponentReferenceVersion {
		@JsonProperty private String version;
		@JsonProperty private String range;
		@JsonProperty private ComponentReferenceVersionStatus status;
	}
	
	public static enum ComponentReferenceVersionStatus {
		affected, unaffected, unknown
	}

	public String getIssueUrl(Bom bom) {
		if ( bom.getToolName().toLowerCase().contains("debricked") && StringUtils.isNotBlank(getId()) ) {
			return String.format("https://debricked.com/vulnerability-database/vulnerability/%s", getId());
		} else if ( source!=null && StringUtils.isNotBlank(source.getUrl())
				// Dependency-Track doesn't provide a deep link in source, so we won't use source URL for Dependency-Track
				&& !bom.getToolName().toLowerCase().contains("dependency-track") ) {
			return source.getUrl();
		} else if ( StringUtils.isNotBlank(getId()) && getId().toLowerCase().startsWith("cve") ) {
			return String.format("https://cve.mitre.org/cgi-bin/cvename.cgi?name=%s", getId());
		} else {
			return null;
		}
	}

	public String getCwesAsString() {
		String result = "";
		if ( cwes!=null && cwes.length>0 ) {
			result = IntStream.of(cwes)
                    .mapToObj(Integer::toString)
                    .collect(Collectors.joining(", "));
		}
		return result;
	}

	public String getInvokedAsString() {
		// TODO Auto-generated method stub
		return null;
	}

	public String getControllableAsString() {
		// TODO Auto-generated method stub
		return null;
	}

	public String getEvidenceUrl() {
		// TODO Auto-generated method stub
		return null;
	}
	
	public final VulnerabilityRating getHighestVulnerabilityRating() {
	    VulnerabilityRating result = VulnerabilityRating.builder()
	            .method(VulnerabilityRatingMethod.not_available)
	            .score(0.0f)
	            .severity(VulnerabilityRatingSeverity.none)
	            .vector("N/A").build();
	    if ( ratings!=null ) {
	        for ( VulnerabilityRating rating : ratings ) {
	            VulnerabilityRatingMethod method = rating.getMethod();
	            if ( method!=null && method.ordinal()<result.getMethod().ordinal()) {
	                result = rating;
	            }
	        }
	    }
	    return result;
	}
}